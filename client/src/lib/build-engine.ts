/**
 * Core orchestration engine for the agentic build pipeline.
 *
 * Controls the entire build process:
 *   Planning → Phase loop (file creation → review → fixes) → Final summary
 *
 * Each file is generated by exactly one AI call. The application code — not the AI —
 * controls what happens at every step.
 */

import { generateAI, type AIGenerateOptions } from "./ai-client";
import { apiRequest } from "./queryClient";
import {
  buildPlanningPrompt,
  buildFileGenerationPrompt,
  buildReviewPrompt,
  buildSummaryPrompt,
  buildContinuationPrompt,
} from "./build-prompts";

// ─── Types ───────────────────────────────────────────────────────────────

export interface BuildPlan {
  pluginName: string;
  packageName: string;
  description: string;
  phases: BuildPhase[];
}

export interface BuildPhase {
  name: string;
  description: string;
  files: PlannedFile[];
}

export interface PlannedFile {
  path: string;
  name: string;
  description: string;
}

export interface PhaseState {
  name: string;
  description: string;
  status: "pending" | "active" | "reviewing" | "complete";
  files: FileState[];
}

export interface FileState {
  path: string;
  name: string;
  description: string;
  status: "pending" | "generating" | "created" | "updating" | "updated" | "error";
  error?: string;
}

export type BuildStatus =
  | "idle"
  | "planning"
  | "building"
  | "reviewing"
  | "complete"
  | "error"
  | "cancelled";

export interface BuildState {
  status: BuildStatus;
  plan: BuildPlan | null;
  phases: PhaseState[];
  thinkingMessage: string | null;
  summary: string | null;
  error: string | null;
}

export type BuildEvent =
  | { type: "planning" }
  | { type: "plan-ready"; plan: BuildPlan }
  | { type: "conversation-response"; content: string }
  | { type: "phase-start"; phaseIndex: number }
  | { type: "file-generating"; phaseIndex: number; fileIndex: number }
  | { type: "file-created"; phaseIndex: number; fileIndex: number; path: string }
  | { type: "file-updated"; phaseIndex: number; fileIndex: number; path: string }
  | { type: "file-error"; phaseIndex: number; fileIndex: number; error: string }
  | { type: "phase-reviewing"; phaseIndex: number }
  | { type: "phase-complete"; phaseIndex: number }
  | { type: "build-complete"; summary: string }
  | { type: "build-error"; error: string }
  | { type: "thinking"; message: string };

export const INITIAL_BUILD_STATE: BuildState = {
  status: "idle",
  plan: null,
  phases: [],
  thinkingMessage: null,
  summary: null,
  error: null,
};

/**
 * Reducer for build state — processes build events into state updates.
 */
export function buildReducer(state: BuildState, event: BuildEvent): BuildState {
  switch (event.type) {
    case "planning":
      return { ...state, status: "planning", thinkingMessage: "Analyzing your request..." };

    case "plan-ready":
      return {
        ...state,
        status: "building",
        plan: event.plan,
        thinkingMessage: null,
        phases: event.plan.phases.map((p) => ({
          name: p.name,
          description: p.description,
          status: "pending",
          files: p.files.map((f) => ({
            path: f.path,
            name: f.name,
            description: f.description,
            status: "pending",
          })),
        })),
      };

    case "conversation-response":
      return { ...INITIAL_BUILD_STATE };

    case "phase-start": {
      const phases = [...state.phases];
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], status: "active" };
      return { ...state, phases, thinkingMessage: null };
    }

    case "file-generating": {
      const phases = [...state.phases];
      const files = [...phases[event.phaseIndex].files];
      files[event.fileIndex] = { ...files[event.fileIndex], status: "generating" };
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], files };
      const fileName = files[event.fileIndex].name;
      return { ...state, phases, thinkingMessage: `Generating ${fileName}...` };
    }

    case "file-created": {
      const phases = [...state.phases];
      const files = [...phases[event.phaseIndex].files];
      files[event.fileIndex] = { ...files[event.fileIndex], status: "created" };
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], files };
      return { ...state, phases, thinkingMessage: null };
    }

    case "file-updated": {
      const phases = [...state.phases];
      const files = [...phases[event.phaseIndex].files];
      files[event.fileIndex] = { ...files[event.fileIndex], status: "updated" };
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], files };
      return { ...state, phases, thinkingMessage: null };
    }

    case "file-error": {
      const phases = [...state.phases];
      const files = [...phases[event.phaseIndex].files];
      files[event.fileIndex] = { ...files[event.fileIndex], status: "error", error: event.error };
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], files };
      return { ...state, phases, thinkingMessage: null };
    }

    case "phase-reviewing": {
      const phases = [...state.phases];
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], status: "reviewing" };
      return { ...state, status: "reviewing", phases, thinkingMessage: "Reviewing phase..." };
    }

    case "phase-complete": {
      const phases = [...state.phases];
      phases[event.phaseIndex] = { ...phases[event.phaseIndex], status: "complete" };
      return { ...state, status: "building", phases, thinkingMessage: null };
    }

    case "build-complete":
      return { ...state, status: "complete", summary: event.summary, thinkingMessage: null };

    case "build-error":
      return { ...state, status: "error", error: event.error, thinkingMessage: null };

    case "thinking":
      return { ...state, thinkingMessage: event.message };

    default:
      return state;
  }
}

// ─── Engine ──────────────────────────────────────────────────────────────

interface RunBuildParams {
  userRequest: string;
  sessionId: number;
  model: { id: number; name: string; providerAuthType?: string | null };
  framework: string;
  onEvent: (event: BuildEvent) => void;
  signal: AbortSignal;
}

const MAX_RETRIES = 3;
const RETRY_DELAYS = [1000, 3000, 7000];
const MAX_CONTEXT_SIZE = 50_000; // 50KB of file context per AI call
const MAX_CONTINUATIONS = 3;

/**
 * Runs the full agentic build pipeline.
 */
export async function runBuild(params: RunBuildParams): Promise<void> {
  const { userRequest, sessionId, model, framework, onEvent, signal } = params;

  // In-memory record of all file contents — used for context injection
  const fileMemory = new Map<string, string>();
  // Map of filePath → DB file ID for updates
  const fileIdMap = new Map<string, number>();

  // Helper: call AI with retry and auto-continuation
  async function callAI(
    systemPrompt: string,
    userContent: string,
    maxTokens?: number,
  ): Promise<string> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      if (signal.aborted) throw new Error("Build cancelled");

      try {
        const result = await generateAI({
          model,
          systemPrompt,
          messages: [{ role: "user", content: userContent }],
          sessionId,
          maxTokens,
          signal,
        });

        // Auto-continuation: if response was truncated
        let fullText = result.text;
        if (result.finishReason === "length" && fullText.length > 0) {
          for (let cont = 0; cont < MAX_CONTINUATIONS; cont++) {
            if (signal.aborted) break;
            const contPrompt = buildContinuationPrompt("file", fullText.slice(-2000));
            const contResult = await generateAI({
              model,
              systemPrompt: contPrompt,
              messages: [{ role: "user", content: "Continue." }],
              sessionId,
              maxTokens,
              signal,
            });
            fullText += contResult.text;
            if (contResult.finishReason !== "length") break;
          }
        }

        return fullText;
      } catch (e: any) {
        lastError = e;
        if (e.message === "Build cancelled" || signal.aborted) throw e;
        if (attempt < MAX_RETRIES) {
          await sleep(RETRY_DELAYS[attempt]);
        }
      }
    }

    throw lastError || new Error("AI call failed after retries");
  }

  // Helper: write a file to the file system via API
  async function writeFile(filePath: string, fileName: string, content: string): Promise<number> {
    const existingId = fileIdMap.get(filePath);

    if (existingId) {
      // Update existing file
      const response = await apiRequest("PATCH", `/api/files/${existingId}`, {
        content,
        name: fileName,
        path: filePath,
      });
      const file = await response.json();
      fileMemory.set(filePath, content);
      return file.id;
    }

    // Create new file
    const response = await apiRequest("POST", `/api/sessions/${sessionId}/files`, {
      name: fileName,
      path: filePath,
      content,
      isFolder: false,
    });
    const file = await response.json();
    fileMemory.set(filePath, content);
    fileIdMap.set(filePath, file.id);
    return file.id;
  }

  // Helper: report token usage
  async function reportTokenUsage(inputChars: number, outputChars: number): Promise<void> {
    try {
      await apiRequest("POST", "/api/token-usage/apply", {
        sessionId,
        modelId: model.id,
        inputChars,
        outputChars,
        action: "chat",
      });
    } catch {
      // Token accounting failure should not break the build
    }
  }

  // Helper: build project context string from file memory
  function buildProjectContext(): string {
    if (fileMemory.size === 0) return "No files created yet.";

    let context = "Files created so far:\n";
    let totalSize = 0;

    const entries = Array.from(fileMemory.entries());
    for (const [path, content] of entries) {
      const entry = `\n--- ${path} ---\n${content}\n`;
      if (totalSize + entry.length > MAX_CONTEXT_SIZE) {
        // Truncate large files, keep listing all paths
        const remaining = MAX_CONTEXT_SIZE - totalSize;
        if (remaining > 100) {
          context += `\n--- ${path} ---\n${content.slice(0, remaining - 50)}\n[... truncated ...]\n`;
        } else {
          context += `\n- ${path} (content omitted for brevity)`;
        }
        totalSize = MAX_CONTEXT_SIZE;
      } else {
        context += entry;
        totalSize += entry.length;
      }
    }

    return context;
  }

  // ─── Pipeline starts here ─────────────────────────────────────────────

  try {
    // 1. Save user message
    await apiRequest("POST", `/api/sessions/${sessionId}/messages`, {
      role: "user",
      content: userRequest,
      modelId: model.id,
    });

    // 2. Planning
    onEvent({ type: "planning" });
    const planningPrompt = buildPlanningPrompt(userRequest, framework);
    const planRaw = await callAI(planningPrompt, userRequest);

    // Parse the JSON plan (strip markdown fences if AI wrapped them)
    let planJson: any;
    try {
      const cleaned = planRaw
        .replace(/^```(?:json)?\s*\n?/m, "")
        .replace(/\n?```\s*$/m, "")
        .trim();
      planJson = JSON.parse(cleaned);
    } catch {
      // If JSON parse fails, try extracting JSON from the response
      const jsonMatch = planRaw.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          planJson = JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error("Failed to parse build plan from AI response");
        }
      } else {
        throw new Error("AI did not return a valid build plan");
      }
    }

    // Handle conversation response (non-build request)
    if (planJson.type === "conversation") {
      await apiRequest("POST", `/api/sessions/${sessionId}/messages`, {
        role: "assistant",
        content: planJson.response,
        modelId: model.id,
      });
      onEvent({ type: "conversation-response", content: planJson.response });
      return;
    }

    // Validate plan structure
    const plan: BuildPlan = {
      pluginName: planJson.pluginName || "Plugin",
      packageName: planJson.packageName || "com.example.plugin",
      description: planJson.description || "",
      phases: (planJson.phases || []).map((p: any) => ({
        name: p.name || "Phase",
        description: p.description || "",
        files: (p.files || []).map((f: any) => ({
          path: f.path || f.name || "unknown",
          name: f.name || f.path?.split("/").pop() || "unknown",
          description: f.description || "",
        })),
      })),
    };

    if (plan.phases.length === 0 || plan.phases.every((p) => p.files.length === 0)) {
      throw new Error("Build plan contains no files to generate");
    }

    // Save plan as assistant message
    const planSummary = `**Build Plan: ${plan.pluginName}**\n\n${plan.description}\n\n${plan.phases
      .map(
        (p, i) =>
          `**Phase ${i + 1}: ${p.name}**\n${p.files.map((f) => `- \`${f.path}\` — ${f.description}`).join("\n")}`,
      )
      .join("\n\n")}`;

    await apiRequest("POST", `/api/sessions/${sessionId}/messages`, {
      role: "assistant",
      content: planSummary,
      modelId: model.id,
    });

    onEvent({ type: "plan-ready", plan });

    // 3. Phase loop
    for (let phaseIdx = 0; phaseIdx < plan.phases.length; phaseIdx++) {
      if (signal.aborted) throw new Error("Build cancelled");

      const phase = plan.phases[phaseIdx];
      onEvent({ type: "phase-start", phaseIndex: phaseIdx });

      // 3a. File creation loop — one file per AI call
      for (let fileIdx = 0; fileIdx < phase.files.length; fileIdx++) {
        if (signal.aborted) throw new Error("Build cancelled");

        const file = phase.files[fileIdx];
        onEvent({ type: "file-generating", phaseIndex: phaseIdx, fileIndex: fileIdx });

        try {
          const filePrompt = buildFileGenerationPrompt(
            file.path,
            file.name,
            file.description,
            phase.name,
            buildProjectContext(),
            framework,
            plan.packageName,
          );

          const fileContent = await callAI(filePrompt, `Generate ${file.path}`);
          await writeFile(file.path, file.name, fileContent);
          await reportTokenUsage(filePrompt.length, fileContent.length);

          onEvent({ type: "file-created", phaseIndex: phaseIdx, fileIndex: fileIdx, path: file.path });
        } catch (e: any) {
          if (e.message === "Build cancelled") throw e;
          onEvent({
            type: "file-error",
            phaseIndex: phaseIdx,
            fileIndex: fileIdx,
            error: e.message || "Unknown error",
          });
          // Continue to next file — don't stop the whole build
        }
      }

      // 3b. Phase review
      if (signal.aborted) throw new Error("Build cancelled");
      onEvent({ type: "phase-reviewing", phaseIndex: phaseIdx });

      try {
        const phaseFiles = phase.files
          .filter((f) => fileMemory.has(f.path))
          .map((f) => ({ path: f.path, content: fileMemory.get(f.path)! }));

        if (phaseFiles.length > 0) {
          const reviewPrompt = buildReviewPrompt(phaseFiles, framework);
          const reviewRaw = await callAI(reviewPrompt, "Review these files.");

          let reviewResult: any;
          try {
            const cleaned = reviewRaw
              .replace(/^```(?:json)?\s*\n?/m, "")
              .replace(/\n?```\s*$/m, "")
              .trim();
            reviewResult = JSON.parse(cleaned);
          } catch {
            const jsonMatch = reviewRaw.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              try {
                reviewResult = JSON.parse(jsonMatch[0]);
              } catch {
                reviewResult = { passed: true };
              }
            } else {
              reviewResult = { passed: true };
            }
          }

          // 3c. Fix loop — if review found issues
          if (!reviewResult.passed && Array.isArray(reviewResult.fixes)) {
            for (const fix of reviewResult.fixes) {
              if (signal.aborted) throw new Error("Build cancelled");

              const fileIdx = phase.files.findIndex((f) => f.path === fix.path);
              if (fileIdx === -1) continue;

              const file = phase.files[fileIdx];
              onEvent({ type: "file-generating", phaseIndex: phaseIdx, fileIndex: fileIdx });

              try {
                const fixPrompt = buildFileGenerationPrompt(
                  file.path,
                  file.name,
                  `${file.description}. FIX REQUIRED: ${fix.reason}`,
                  phase.name,
                  buildProjectContext(),
                  framework,
                  plan.packageName,
                );

                const fixedContent = await callAI(fixPrompt, `Fix and regenerate ${file.path}: ${fix.reason}`);
                await writeFile(file.path, file.name, fixedContent);
                await reportTokenUsage(fixPrompt.length, fixedContent.length);

                onEvent({ type: "file-updated", phaseIndex: phaseIdx, fileIndex: fileIdx, path: file.path });
              } catch (e: any) {
                if (e.message === "Build cancelled") throw e;
                onEvent({
                  type: "file-error",
                  phaseIndex: phaseIdx,
                  fileIndex: fileIdx,
                  error: e.message || "Fix failed",
                });
              }
            }
          }
        }
      } catch (e: any) {
        if (e.message === "Build cancelled") throw e;
        // Review failure is non-fatal — we still have the files
        console.error("Phase review error:", e);
      }

      onEvent({ type: "phase-complete", phaseIndex: phaseIdx });
    }

    // 4. Final summary
    if (signal.aborted) throw new Error("Build cancelled");
    onEvent({ type: "thinking", message: "Generating build summary..." });

    const summaryPrompt = buildSummaryPrompt(
      plan.pluginName,
      plan.description,
      plan.phases,
      framework,
    );

    const summary = await callAI(summaryPrompt, "Generate the build completion summary.");

    // Save summary as assistant message
    await apiRequest("POST", `/api/sessions/${sessionId}/messages`, {
      role: "assistant",
      content: summary,
      modelId: model.id,
    });

    onEvent({ type: "build-complete", summary });
  } catch (e: any) {
    if (e.message === "Build cancelled" || signal.aborted) {
      onEvent({ type: "build-error", error: "Build was cancelled" });
    } else {
      onEvent({ type: "build-error", error: e.message || "Build failed unexpectedly" });
    }
  }
}

// ─── Helpers ─────────────────────────────────────────────────────────────

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
